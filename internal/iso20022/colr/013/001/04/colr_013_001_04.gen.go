// Code generated by main. DO NOT EDIT.

package colr_013_001_04

import (
	"bytes"
	"encoding/xml"
	"time"
)

type ActiveCurrencyAndAmount struct {
	Value float64            `xml:",chardata"`
	Ccy   ActiveCurrencyCode `xml:"Ccy,attr"`
}

// Must match the pattern [A-Z]{3,3}
type ActiveCurrencyCode string

type Agreement4 struct {
	AgrmtDtls  Max140Text                `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 AgrmtDtls"`
	AgrmtId    Max140Text                `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 AgrmtId,omitempty"`
	AgrmtDt    ISODate                   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 AgrmtDt"`
	BaseCcy    ActiveCurrencyCode        `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 BaseCcy"`
	AgrmtFrmwk AgreementFramework1Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 AgrmtFrmwk,omitempty"`
}

type AgreementFramework1Choice struct {
	AgrmtFrmwk AgreementFramework1Code `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 AgrmtFrmwk"`
	PrtryId    GenericIdentification30 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 PrtryId"`
}

// May be one of FBAA, BBAA, DERV, ISDA, NONR
type AgreementFramework1Code string

// Must match the pattern [A-Z]{6,6}[A-Z2-9][A-NP-Z0-9]([A-Z0-9]{3,3}){0,1}
type AnyBICIdentifier string

// May be one of SIMP, COMP
type CalculationMethod1Code string

type CollateralAccount2 struct {
	Id Max35Text                                  `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Id"`
	Tp CollateralAccountIdentificationType2Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Tp,omitempty"`
	Nm Max70Text                                  `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Nm,omitempty"`
}

type CollateralAccountIdentificationType2Choice struct {
	Tp    CollateralAccountType1Code `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Tp,omitempty"`
	Prtry GenericIdentification36    `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Prtry"`
}

// May be one of HOUS, CLIE, LIPR, MGIN, DFLT
type CollateralAccountType1Code string

type CollateralBalance1 struct {
	HeldByPtyA ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 HeldByPtyA"`
	HeldByPtyB ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 HeldByPtyB"`
}

type CollateralPurpose1Choice struct {
	Cd    CollateralPurpose1Code  `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Cd"`
	Prtry GenericIdentification30 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Prtry"`
}

// May be one of VAMA, SINA
type CollateralPurpose1Code string

// Must match the pattern [A-Z]{2,2}
type CountryCode string

type DateAndDateTimeChoice struct {
	Dt   ISODate     `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Dt"`
	DtTm ISODateTime `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 DtTm"`
}

type DatePeriodDetails struct {
	FrDt ISODate `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 FrDt"`
	ToDt ISODate `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 ToDt"`
}

type Document struct {
	IntrstPmtReq InterestPaymentRequestV04 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 IntrstPmtReq"`
}

// Must match the pattern [a-zA-Z0-9]{4}
type Exact4AlphaNumericText string

// May be one of BFWD, PAYM, CCPC, COMM, CRDS, CRTL, CRSP, CCIR, CRPR, EQUI, EQPT, EQUS, EXTD, EXPT, FIXI, FORX, FORW, FUTR, OPTN, LIQU, OTCD, REPO, RVPO, SLOA, SBSC, SCRP, SLEB, SHSL, SCIR, SCIE, SWPT, TBAS, TRBD, TRCP
type ExposureType5Code string

// May be one of YEAR, MNTH, QURT, MIAN, WEEK, DAIL, ADHO, INDA
type Frequency1Code string

type GenericIdentification30 struct {
	Id      Exact4AlphaNumericText `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Id"`
	Issr    Max35Text              `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Issr"`
	SchmeNm Max35Text              `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 SchmeNm,omitempty"`
}

type GenericIdentification36 struct {
	Id      Max35Text `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Id"`
	Issr    Max35Text `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Issr"`
	SchmeNm Max35Text `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 SchmeNm,omitempty"`
}

type ISODate time.Time

func (t *ISODate) UnmarshalText(text []byte) error {
	return (*xsdDate)(t).UnmarshalText(text)
}
func (t ISODate) MarshalText() ([]byte, error) {
	return xsdDate(t).MarshalText()
}

type ISODateTime time.Time

func (t *ISODateTime) UnmarshalText(text []byte) error {
	return (*xsdDateTime)(t).UnmarshalText(text)
}
func (t ISODateTime) MarshalText() ([]byte, error) {
	return xsdDateTime(t).MarshalText()
}

type InterestAmount1 struct {
	IntrstReqSeq   InterestRequestSequence1Code   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 IntrstReqSeq"`
	IntrstPrd      DatePeriodDetails              `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 IntrstPrd"`
	AcrdIntrstAmt  ActiveCurrencyAndAmount        `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 AcrdIntrstAmt"`
	ValDt          ISODate                        `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 ValDt"`
	IntrstMtd      InterestMethod1Code            `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 IntrstMtd"`
	IntrstRate     InterestRate1Choice            `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 IntrstRate,omitempty"`
	DayCntBsis     InterestComputationMethod2Code `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 DayCntBsis,omitempty"`
	ApldWhldgTax   bool                           `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 ApldWhldgTax,omitempty"`
	ClctnMtd       CalculationMethod1Code         `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 ClctnMtd,omitempty"`
	ClctnFrqcy     Frequency1Code                 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 ClctnFrqcy,omitempty"`
	CollPurp       CollateralPurpose1Choice       `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 CollPurp"`
	OpngCollBal    CollateralBalance1             `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 OpngCollBal,omitempty"`
	ClsgCollBal    CollateralBalance1             `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 ClsgCollBal"`
	StdSttlmInstrs Max140Text                     `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 StdSttlmInstrs,omitempty"`
	AddtlInf       Max210Text                     `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 AddtlInf,omitempty"`
	RefDtls        Reference20                    `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 RefDtls,omitempty"`
}

// May be one of A001, A002, A003, A004, A005, A006, A007, A008, A009, A010, A011, A012, A013, A014, NARR
type InterestComputationMethod2Code string

// May be one of PHYS, ROLL
type InterestMethod1Code string

type InterestPaymentRequestV04 struct {
	TxId         Max35Text            `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 TxId"`
	Oblgtn       Obligation4          `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Oblgtn"`
	Agrmt        Agreement4           `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Agrmt"`
	IntrstDueToA InterestAmount1      `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 IntrstDueToA,omitempty"`
	IntrstDueToB InterestAmount1      `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 IntrstDueToB,omitempty"`
	NetAmtDtls   InterestResult1      `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 NetAmtDtls,omitempty"`
	SplmtryData  []SupplementaryData1 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 SplmtryData,omitempty"`
}

type InterestRate1Choice struct {
	FxdIntrstRate   float64               `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 FxdIntrstRate"`
	VarblIntrstRate VariableInterest1Rate `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 VarblIntrstRate"`
}

// May be one of INIT, UPDA
type InterestRequestSequence1Code string

type InterestResult1 struct {
	IntrstDueToA ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 IntrstDueToA,omitempty"`
	IntrstDueToB ActiveCurrencyAndAmount `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 IntrstDueToB,omitempty"`
	ValDt        ISODate                 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 ValDt"`
	IntrstMtd    InterestMethod1Code     `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 IntrstMtd"`
	OpngCollBal  CollateralBalance1      `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 OpngCollBal,omitempty"`
	ClsgCollBal  CollateralBalance1      `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 ClsgCollBal"`
}

// Must be at least 1 items long
type Max140Text string

// Must be at least 1 items long
type Max16Text string

// Must be at least 1 items long
type Max210Text string

// Must be at least 1 items long
type Max350Text string

// Must be at least 1 items long
type Max35Text string

// Must be at least 1 items long
type Max70Text string

type NameAndAddress6 struct {
	Nm  Max70Text      `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Nm"`
	Adr PostalAddress2 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Adr"`
}

type Obligation4 struct {
	PtyA       PartyIdentification100Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 PtyA"`
	SvcgPtyA   PartyIdentification100Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 SvcgPtyA,omitempty"`
	PtyB       PartyIdentification100Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 PtyB"`
	SvcgPtyB   PartyIdentification100Choice `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 SvcgPtyB,omitempty"`
	CollAcctId CollateralAccount2           `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 CollAcctId,omitempty"`
	XpsrTp     ExposureType5Code            `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 XpsrTp,omitempty"`
	ValtnDt    DateAndDateTimeChoice        `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 ValtnDt"`
}

type PartyIdentification100Choice struct {
	AnyBIC   AnyBICIdentifier        `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 AnyBIC"`
	PrtryId  GenericIdentification36 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 PrtryId"`
	NmAndAdr NameAndAddress6         `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 NmAndAdr"`
}

type PostalAddress2 struct {
	StrtNm      Max70Text   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 StrtNm,omitempty"`
	PstCdId     Max16Text   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 PstCdId"`
	TwnNm       Max35Text   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 TwnNm"`
	CtrySubDvsn Max35Text   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 CtrySubDvsn,omitempty"`
	Ctry        CountryCode `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Ctry"`
}

type Reference20 struct {
	IntrstPmtReqId  Max35Text `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 IntrstPmtReqId"`
	IntrstPmtRspnId Max35Text `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 IntrstPmtRspnId,omitempty"`
}

type SupplementaryData1 struct {
	PlcAndNm Max350Text                 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 PlcAndNm,omitempty"`
	Envlp    SupplementaryDataEnvelope1 `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Envlp"`
}

type SupplementaryDataEnvelope1 struct {
	Item string `xml:",any"`
}

type VariableInterest1Rate struct {
	Indx       Max35Text `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 Indx"`
	BsisPtSprd float64   `xml:"urn:iso:std:iso:20022:tech:xsd:colr.013.001.04 BsisPtSprd,omitempty"`
}

type xsdDate time.Time

func (t *xsdDate) UnmarshalText(text []byte) error {
	return _unmarshalTime(text, (*time.Time)(t), "2006-01-02")
}
func (t xsdDate) MarshalText() ([]byte, error) {
	return _marshalTime((time.Time)(t), "2006-01-02")
}
func (t xsdDate) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if (time.Time)(t).IsZero() {
		return nil
	}
	m, err := t.MarshalText()
	if err != nil {
		return err
	}
	return e.EncodeElement(m, start)
}
func (t xsdDate) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	if (time.Time)(t).IsZero() {
		return xml.Attr{}, nil
	}
	m, err := t.MarshalText()
	return xml.Attr{Name: name, Value: string(m)}, err
}
func _unmarshalTime(text []byte, t *time.Time, format string) (err error) {
	s := string(bytes.TrimSpace(text))
	*t, err = time.Parse(format, s)
	if _, ok := err.(*time.ParseError); ok {
		*t, err = time.Parse(format+"Z07:00", s)
	}
	return err
}
func _marshalTime(t time.Time, format string) ([]byte, error) {
	return []byte(t.Format(format + "Z07:00")), nil
}

type xsdDateTime time.Time

func (t *xsdDateTime) UnmarshalText(text []byte) error {
	return _unmarshalTime(text, (*time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalText() ([]byte, error) {
	return _marshalTime((time.Time)(t), "2006-01-02T15:04:05.999999999")
}
func (t xsdDateTime) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	if (time.Time)(t).IsZero() {
		return nil
	}
	m, err := t.MarshalText()
	if err != nil {
		return err
	}
	return e.EncodeElement(m, start)
}
func (t xsdDateTime) MarshalXMLAttr(name xml.Name) (xml.Attr, error) {
	if (time.Time)(t).IsZero() {
		return xml.Attr{}, nil
	}
	m, err := t.MarshalText()
	return xml.Attr{Name: name, Value: string(m)}, err
}
